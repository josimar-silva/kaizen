const fs = require("fs");
const path = require("path");

const dataJsonPath = path.join(__dirname, "..", "public", "data.json");
const outputDir = path.join(__dirname, "..", "src", "lib");
const outputPath = path.join(outputDir, "db.ts");
const publicSolutionDir = path.join(__dirname, "..", "public", "solution");

try {
  // Ensure public/solution directory exists
  if (!fs.existsSync(publicSolutionDir)) {
    fs.mkdirSync(publicSolutionDir, { recursive: true });
  }

  // 1. Read data.json
  const rawData = fs.readFileSync(dataJsonPath, "utf-8");
  const jsonData = JSON.parse(rawData); // { stats: {}, commits: {} }

  // 2. Transform commits data and copy analysis markdown files
  const transformedCommits = {};
  for (const date in jsonData.commits) {
    if (Object.hasOwn(jsonData.commits, date)) {
      transformedCommits[date] = jsonData.commits[date].map(
        ({ type_of, analysis, ...rest }) => {
          let type = type_of;
          if (type === "algo") {
            type = "algorithm";
          } else if (type === "sysdes") {
            type = "system-design";
          }
          if (analysis) {
            // Validate analysis path
            if (!analysis.endsWith(".md")) {
              console.warn(
                `Warning: Analysis file ${analysis} is not a markdown file. Skipping.`,
              );
              return { ...rest, type };
            }
            // Prevent path traversal
            const normalizedPath = path.normalize(analysis);
            if (
              normalizedPath.includes("..") ||
              path.isAbsolute(normalizedPath)
            ) {
              console.error(
                `Error: Analysis path ${analysis} contains path traversal or is absolute. Skipping.`,
              );
              return { ...rest, type };
            }
            const sourceAnalysisPath = path.join(
              __dirname,
              "..",
              "..",
              analysis,
            );
            const destinationAnalysisFileName = path.basename(analysis);
            const destinationAnalysisPath = path.join(
              publicSolutionDir,
              destinationAnalysisFileName,
            );
            if (fs.existsSync(sourceAnalysisPath)) {
              // Warn if overwriting existing file
              if (fs.existsSync(destinationAnalysisPath)) {
                console.warn(
                  `Warning: Overwriting existing file: ${destinationAnalysisFileName}`,
                );
              }
              fs.copyFileSync(sourceAnalysisPath, destinationAnalysisPath);
              console.log(
                `Copied analysis file: ${destinationAnalysisFileName}`,
              );
            } else {
              console.warn(
                `Warning: Analysis file not found at ${sourceAnalysisPath}`,
              );
              return { ...rest, type };
            }
            return {
              ...rest,
              type,
              analysis: `/solution/${destinationAnalysisFileName}`,
            };
          }
          return { ...rest, type };
        },
      );
    }
  }

  // 3. Calculate additional stats
  const allCommits = Object.values(transformedCommits).flat();

  const typeDistribution = allCommits.reduce((acc, commit) => {
    const type = commit.type || "algorithm";
    acc[type] = (acc[type] || 0) + 1;
    return acc;
  }, {});

  const avgSolutionsPerWeek =
    Math.floor(
      (jsonData.stats.totalAlgorithms /
        Math.max(jsonData.stats.totalDays / 7, 1)) *
        10,
    ) / 10;

  const commitDates = Object.keys(transformedCommits);
  const earliestCommitDate =
    commitDates.length > 0
      ? commitDates.reduce(
          (min, current) => (current < min ? current : min),
          commitDates[0],
        )
      : null;
  const daysSinceFirstActivity = earliestCommitDate
    ? Math.floor(
        (Date.now() - new Date(earliestCommitDate).getTime()) /
          (1000 * 60 * 60 * 24),
      )
    : 0;

  // 4. Combine stats and transformed commits
  const finalData = {
    stats: {
      ...jsonData.stats,
      typeDistribution,
      avgSolutionsPerWeek,
      daysSinceFirstActivity,
    },
    commits: transformedCommits,
  };

  // 5. Generate file content
  const dataString = JSON.stringify(finalData, null, 2);
  const fileContent = `// This file is auto-generated by the pre-build script. Do not edit manually.
import { KaizenData } from "@/interfaces/kaizen-data";

export const kaizenData: KaizenData = ${dataString};
`;

  // 6. Write to db.ts
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  fs.writeFileSync(outputPath, fileContent, "utf-8");

  console.log(`Successfully generated ${outputPath}`);
} catch (error) {
  console.error("Error during pre-build script execution:", error);
  process.exit(1);
}
