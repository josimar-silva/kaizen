const fs = require("fs");
const path = require("path");

const dataJsonPath = path.join(__dirname, "..", "public", "data.json");
const outputDir = path.join(__dirname, "..", "src", "lib");
const outputPath = path.join(outputDir, "db.ts");
const publicSolutionDir = path.join(__dirname, "..", "public", "solution");

try {
  // Ensure public/solution directory exists
  if (!fs.existsSync(publicSolutionDir)) {
    fs.mkdirSync(publicSolutionDir, { recursive: true });
  }

  // 1. Read data.json
  const rawData = fs.readFileSync(dataJsonPath, "utf-8");
  const jsonData = JSON.parse(rawData); // { stats: {}, commits: {} }

  // 2. Transform commits data and copy analysis markdown files
  const transformedCommits = {};
  for (const date in jsonData.commits) {
    if (Object.hasOwn(jsonData.commits, date)) {
      transformedCommits[date] = jsonData.commits[date].map(
        ({ type_of, analysis, ...rest }) => {
          let type = type_of;
          if (type === "algo") {
            type = "algorithm";
          } else if (type === "sysdes") {
            type = "system-design";
          }
          if (analysis) {
            // Validate analysis path
            if (!analysis.endsWith(".md")) {
              console.warn(
                `Warning: Analysis file ${analysis} is not a markdown file. Skipping.`,
              );
              return { ...rest, type };
            }
            // Prevent path traversal
            const normalizedPath = path.normalize(analysis);
            if (
              normalizedPath.includes("..") ||
              path.isAbsolute(normalizedPath)
            ) {
              console.error(
                `Error: Analysis path ${analysis} contains path traversal or is absolute. Skipping.`,
              );
              return { ...rest, type };
            }
            const sourceAnalysisPath = path.join(
              __dirname,
              "..",
              "..",
              analysis,
            );
            const destinationAnalysisFileName = path.basename(analysis);
            const destinationAnalysisPath = path.join(
              publicSolutionDir,
              destinationAnalysisFileName,
            );
            if (fs.existsSync(sourceAnalysisPath)) {
              // Warn if overwriting existing file
              if (fs.existsSync(destinationAnalysisPath)) {
                console.warn(
                  `Warning: Overwriting existing file: ${destinationAnalysisFileName}`,
                );
              }
              fs.copyFileSync(sourceAnalysisPath, destinationAnalysisPath);
              console.log(
                `Copied analysis file: ${destinationAnalysisFileName}`,
              );
            } else {
              console.warn(
                `Warning: Analysis file not found at ${sourceAnalysisPath}`,
              );
              return { ...rest, type };
            }
            return {
              ...rest,
              type,
              analysis: `/solution/${destinationAnalysisFileName}`,
            };
          }
          return { ...rest, type };
        },
      );
    }
  }

  // 3. Combine stats and transformed commits
  const finalData = {
    stats: jsonData.stats,
    commits: transformedCommits,
  };

  // 4. Generate file content
  const dataString = JSON.stringify(finalData, null, 2);
  const fileContent = `// This file is auto-generated by the pre-build script. Do not edit manually.
import { KaizenData } from "@/interfaces/kaizen-data";

export const kaizenData: KaizenData = ${dataString};
`;

  // 5. Write to db.ts
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  fs.writeFileSync(outputPath, fileContent, "utf-8");

  console.log(`Successfully generated ${outputPath}`);
} catch (error) {
  console.error("Error during pre-build script execution:", error);
  process.exit(1);
}
