## Algorithm: Even Fibonacci Numbers

**Source:** [Project Euler](https://projecteuler.net/problem=2)  
**Commit:** [0ae136e](https://github.com/josimar-silva/kaizen/commit/0ae136e045e2914b78ef3507e47cf30f9c95d153)

---

### Problem
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

---

### Big O Analysis

**Time Complexity:**  
- The algorithm generates Fibonacci numbers in a `while` loop until the current number exceeds the given `limit`.
- Fibonacci numbers grow exponentially. The number of terms in the sequence up to a certain limit `L` is proportional to `log(L)`.
- â‡’ **O(log(n))**, where `n` is the limit.

**Space Complexity:**  
- The algorithm uses a few variables (`sum`, `previous`, `current`, `next`) to keep track of the state.
- The amount of memory used is constant and does not scale with the input `limit`.
- â‡’ **O(1)**

---

### Laymanâ€™s Terms

- The algorithm calculates Fibonacci numbers one by one and adds the even ones to a running total.
- It stops when the Fibonacci numbers get bigger than the specified limit (e.g., four million).
- The number of steps it takes is very small compared to the limit. For a limit of 4,000,000, it only needs to generate about 33 Fibonacci numbers.

ðŸ‘‰ **Rule of thumb:** *Even if you increase the limit by a large amount, the number of steps the algorithm takes grows very slowly.*

---

### Reflection

- **Efficiency:** The iterative approach is highly efficient, with logarithmic time complexity and constant space complexity. It is the optimal way to solve this problem.
- **Limits:** The solution is limited by the maximum value of the `long` data type in Java. For limits larger than that, one would need to use a `BigInteger`.
- **Improvements:** The current solution is already optimal. A recursive solution would be much less efficient due to repeated calculations, leading to an exponential time complexity.
- **Lesson Learned:** This problem is a good example of the efficiency of an iterative approach for generating sequences like Fibonacci. It also highlights the dramatic difference in performance between an iterative O(log(n)) solution and a naive recursive O(2^n) solution.

---
