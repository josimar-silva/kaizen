---
title: Three Sum
commit: 17e6901
url: https://github.com/josimar-silva/kaizen/commit/17e69010a4b3d36659f17da325ab15ebd7444de7
---

#### Problem
Given an integer array `nums`, find all the unique triplets `[nums[i], nums[j], nums[k]]` such that their sum is zero. The solution set must not contain duplicate triplets.

---

#### Big O Analysis

**Time Complexity:**  
- The algorithm first sorts the input array, which takes **O(N log N)** time.
- It then iterates through the sorted array with a primary loop (`for`).
- Inside this loop, it uses a two-pointer approach (`while`) to scan the rest of the array. This inner scan takes O(N) time.
- Since the O(N) scan is nested inside the O(N) primary loop, this part of the algorithm is **O(NÂ²)**.
- The total complexity is dominated by the nested loops.
- â‡’ **O(NÂ²)**

**Space Complexity:**  
- The algorithm uses a fixed number of variables (pointers, indices) regardless of the input size.
- The space required for the output list is not typically counted in auxiliary space complexity.
- Sorting can be done in-place (O(1)) or require O(log N) to O(N) space depending on the implementation. Assuming an efficient in-place sort, the auxiliary space is constant.
- â‡’ **O(1)**

---

#### Laymanâ€™s Terms

- For a small array (e.g., 100 numbers), the algorithm is very fast. It performs roughly `100 * 100 = 10,000` operations.
- For the problem's maximum input size (3,000 numbers), it performs about `3,000 * 3,000 = 9,000,000` operations. This is highly manageable, whereas a brute-force O(NÂ³) approach would require `27,000,000,000` operations and would be too slow.

ðŸ‘‰ **Rule of thumb:** *If you double the number of elements in the array, the time it takes to solve the problem increases by roughly a factor of four (quadratic growth).*

---

#### Conclusion

- **Efficiency:** The O(NÂ²) solution is the standard, efficient, and accepted solution for this classic problem. It's a significant improvement over the naive O(NÂ³) brute-force approach.
- **Limits:** The solution is robust and performs well within the given constraints (N <= 3000).
- **Improvements:** The key improvements developed during our session were:
    1.  Moving from a brute-force concept to a **Sort + Two-Pointer** strategy.
    2.  Adding logic to **skip duplicate elements** in both the outer and inner loops, which avoids redundant computations and makes the algorithm more efficient.
- **Lesson Learned:** This problem is a masterclass in algorithmic refinement. The key takeaway is how a **pre-processing step (sorting)** can enable a much more efficient search pattern (the **two-pointer technique**). This transforms a cubic-time problem into a quadratic one and is a fundamental pattern for solving many array-based problems.
